using System;
using System.Linq;
using cAlgo.API;
using cAlgo.API.Indicators;
using cAlgo.API.Internals;
using cAlgo.Indicators;
using System.Timers;

// https://raw.githubusercontent.com/camAtGitHub/cTrader-Stuff/master/SMAShift-MagicMA-cbot.algo
// Requires: SMAShift.algo. When building click 'Manage References', add 'SMAShift'

namespace cAlgo.Robots
{
    [Robot(TimeZone = TimeZones.UTC, AccessRights = AccessRights.None)]
    public class z_MAgicMA : Robot
    {
        #region Private variables

        private DateTime _tradingTime { get; set; }

        #endregion

        [Parameter("Instance Name", DefaultValue = "001", Group = "Name / Volume")]
        public string InstanceName { get; set; }

        [Parameter("Lot Size", DefaultValue = 0.01, Group = "Name / Volume")]
        public double lotsize { get; set; }

        [Parameter("TakeProfitPips", DefaultValue = 10, Group = "TP / SL")]
        public int TP { get; set; }

        [Parameter("StopLossPips", DefaultValue = 10, MinValue = 0, Group = "TP / SL")]
        public int SL { get; set; }

        [Parameter("trigger ", DefaultValue = 20, Group = "TP / SL")]
        public int Trigger { get; set; }

        [Parameter("Trailing", DefaultValue = 10, Group = "TP / SL")]
        public int Trailing { get; set; }

        [Parameter("MA 1 Type", Group = "MA 1")]
        public MovingAverageType MAType1 { get; set; }

        [Parameter("MA 1 Source", Group = "MA 1")]
        public DataSeries Source1 { get; set; }

        [Parameter("MA 1 Periods", DefaultValue = 1, MinValue = 1, MaxValue = 100, Group = "MA 1")]
        public int Period1 { get; set; }

        [Parameter("MA 1 Shift", DefaultValue = 6, MinValue = -100, MaxValue = 500, Group = "MA 1")]
        public int Shift1 { get; set; }

        [Parameter("Range BO High", DefaultValue = 0, MinValue = 0, MaxValue = 999999, Group = "Range BreakOut")]
        public double RBO_H { get; set; }

        [Parameter("Range BO Low", DefaultValue = 0, MinValue = 0, MaxValue = 999999, Group = "Range BreakOut")]
        public double RBO_L { get; set; }

        [Parameter("Buy Orders Only", DefaultValue = false, Group = "OrderTypes")]
        public bool buyOrderOnly { get; set; }

        [Parameter("Sell Orders Only", DefaultValue = false, Group = "OrderTypes")]
        public bool sellOrderOnly { get; set; }

        // If this setting is enabled and you have no positions open
        // then the robot will place a trade on the next onBar(). Might result in poor entries.
        [Parameter("Aggressive re-entry", DefaultValue = false, Group = "OrderTypes")]
        public bool aggressiveReenter { get; set; }

        [Parameter("Print Debug", DefaultValue = true, Group = "Debug")]
        public bool IsDebug { get; set; }

        private SMAShift _ma1 { get; set; }

        public double candleClose;
        public double shiftedMAPrice;
        public bool buySellLogic;
        // true = foo, false = sell 
        protected override void OnStart()
        {
            Print("{0}: TimeFrame is: {1}", Symbol.Name, TimeFrame.ToString());

            _tradingTime = TradingDateTime();
            if (this.IsBacktesting)
            {
                Print("Using server time for trading (UTC+0): " + _tradingTime.ToLongTimeString());
            }
            else
            {
                Print("Using PC time for trading: " + _tradingTime.ToLongTimeString());
            }

            // RBO mode?
            if (RBO_H != 0 || RBO_L != 0)
            {
                Print("INFO: Range BreakOut Mode Enabled.");
                if (RBO_H != 0)
                {
                    Print("INFO: Range BreakOut Mode Enabled. Only buying above: High: {0}", RBO_H);
                }
                if (RBO_L != 0)
                {
                    Print("INFO: Range BreakOut Mode Enabled. Only selling below: Low: {0}", RBO_L);
                }
            }
            // Check for stupid config
            if (buyOrderOnly && sellOrderOnly)
            {
                Print("FATAL: Buy and Sell Order Only both enabled. No trades can be made. Quitting.");
                Stop();
            }

            if (aggressiveReenter)
            {
                Print("INFO: Aggressive re-entry is ENABLED. Trades will opened on next bar and everytime SL or TP is hit");
            }

            // Init our MA indicator
            _ma1 = Indicators.GetIndicator<SMAShift>(MAType1, Source1, Period1, Shift1);

            // Work Out Buy/Sell once per cross-over logic
            int index = MarketSeries.Close.Count - 2;
            candleClose = MarketSeries.Close[index];
            // Set MA to var
            shiftedMAPrice = _ma1.Result.Last(Shift1);
            if (candleClose > shiftedMAPrice)
            {
                debug("DEBUG: Last close above MA. We are in long zone");
                // true = buy/LongZone
                buySellLogic = true;
            }
            else
            {
                debug("DEBUG: Last close below MA. We are in short zone");
                // false = sell/ShortZone
                buySellLogic = false;
            }

        }

        protected override void OnTick()
        {
            TRAILING();
            //debug("Current MA: {0},  Shifted MA: {1}", _ma1.Result.Last(0), _ma1.Result.Last(Shift1));
        }

        protected override void OnBar()
        {
            TRAILING();

            debug("Current MA: {0},  Shifted MA: {1}", _ma1.Result.Last(0), _ma1.Result.Last(Shift1));

            // Configure Price
            // -2 Closed Bar / -1 Current Bar
            int index = MarketSeries.Close.Count - 2;
            candleClose = MarketSeries.Close[index];
            // Set MA to var
            shiftedMAPrice = _ma1.Result.Last(Shift1);

            debug("PreviousBar Close: {0}", candleClose);
            debug("ShiftedMAPrice : {0}", shiftedMAPrice);

            // if buySellLogic is false, we were previously in sell/ShortZone
            if (!buySellLogic || aggressiveReenter)
                if (!sellOrderOnly)
                {
                    // Have we broken out of a range
                    if (candleClose > RBO_H || RBO_H == 0)
                    {
                        if (candleClose > shiftedMAPrice)
                            if (Positions.Count(x => x.TradeType == TradeType.Buy) == 0)
                            {
                                debug("IF1");
                                debug("ExecuteMarketOrder(TradeType.Buy)");
                                debug("ClosePosition(TradeType.Sell)");
                                double volume = Symbol.QuantityToVolumeInUnits(lotsize);
                                ExecuteMarketOrder(TradeType.Buy, this.SymbolName, volume, InstanceName, SL, TP);
                                ClosePosition(TradeType.Sell);
                                buySellLogic = true;
                            }
                    }
                }

            // if buySellLogic is true, we were previously in buy/LongZone
            if (buySellLogic || aggressiveReenter)
                if (!buyOrderOnly)
                {
                    // Have we broken out of a range
                    if (candleClose < RBO_L || RBO_L == 0)
                    {
                        if (candleClose < shiftedMAPrice)
                            if (Positions.Count(x => x.TradeType == TradeType.Sell) == 0)
                            {

                                {
                                    debug("IF2");
                                    debug("ExecuteMarketOrder(TradeType.Sell)");
                                    debug("ClosePosition(TradeType.Buy)");

                                    double volume = Symbol.QuantityToVolumeInUnits(lotsize);
                                    ExecuteMarketOrder(TradeType.Sell, SymbolName, volume, InstanceName, SL, TP);
                                    ClosePosition(TradeType.Buy);
                                    buySellLogic = false;
                                }
                            }
                    }
                }
        }

        protected override void OnStop()
        {
            Stop();
        }

        public DateTime TradingDateTime()
        {
            if (this.IsBacktesting)
            {
                return Server.Time;
            }
            else
            {
                return TimeZoneInfo.ConvertTime(DateTime.Now, TimeZoneInfo.Local);
            }
        }

        private void ClosePosition(TradeType type)
        {
            var p = Positions.Find(InstanceName, this.SymbolName, type);

            if (p != null)
            {
                ClosePosition(p);
                debug("ClosePosition()");
            }
        }

        private void debug(string myMessage)
        {
            if (IsDebug)
            {
                Print(myMessage);
            }
        }
        private void debug(string myMessage, double myMessage2)
        {
            if (IsDebug)
            {
                Print(myMessage, myMessage2);
            }
        }
        private void debug(string myMessage, double myMessage2, double myMessage3)
        {
            if (IsDebug)
            {
                Print(myMessage, myMessage2, myMessage3);
            }
        }


        private void TRAILING()
        {
            if (Trailing > 0 && Trigger > 0)
            {
                Position[] positions = Positions.FindAll(InstanceName, SymbolName);
                foreach (Position position in positions)
                {
                    if (position.TradeType == TradeType.Sell)
                    {
                        double distance = position.EntryPrice - Symbol.Ask;
                        if (distance >= Trigger * Symbol.PipSize)
                        {
                            double newStopLossPrice = Symbol.Ask + Trailing * Symbol.PipSize;
                            if (position.StopLoss == null || newStopLossPrice < position.StopLoss)
                            {
                                //Print("StopLoss / ModifyPosition");
                                ModifyPosition(position, newStopLossPrice, position.TakeProfit);
                            }
                        }
                    }

                    else
                    {
                        double distance = Symbol.Bid - position.EntryPrice;
                        if (distance >= Trigger * Symbol.PipSize)
                        {
                            double newStopLossPrice = Symbol.Bid - Trailing * Symbol.PipSize;
                            if (position.StopLoss == null || newStopLossPrice > position.StopLoss)
                            {
                                //Print("StopLoss / ModifyPosition2");
                                ModifyPosition(position, newStopLossPrice, position.TakeProfit);
                            }
                        }
                    }
                }
            }
        }

    }
}
