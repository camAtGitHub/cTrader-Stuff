using System;
using System.Linq;
using cAlgo.API;
using cAlgo.API.Indicators;
using cAlgo.API.Internals;
using cAlgo.Indicators;
using System.Timers;

// https://raw.githubusercontent.com/camAtGitHub/cTrader-Stuff/master/SMAShift-MagicMA-cbot.algo
// Requires: SMAShift.algo. When building click 'Manage References', add 'SMAShift'

namespace cAlgo.Robots
{
    [Robot(TimeZone = TimeZones.UTC, AccessRights = AccessRights.None)]
    public class z_MAgicMA : Robot
    {
        #region Private variables

        private DateTime _tradingTime { get; set; }

        #endregion

        [Parameter("Instance Name", DefaultValue = "001", Group = "Name / Volume")]
        public string InstanceName { get; set; }

        [Parameter("Lot Size", DefaultValue = 0.01, Group = "Name / Volume")]
        public double lotsize { get; set; }

        [Parameter("TakeProfitPips", DefaultValue = 10, Group = "TP / SL")]
        public int TP { get; set; }

        [Parameter("StopLossPips", DefaultValue = 10, MinValue = 0, Group = "TP / SL")]
        public int SL { get; set; }

        [Parameter("Trail Trigger ", DefaultValue = 20, Group = "TP / SL")]
        public int Trigger { get; set; }

        [Parameter("Trail Distance", DefaultValue = 10, Group = "TP / SL")]
        public int Trailing { get; set; }

        [Parameter("MA 1 Type", Group = "MA 1")]
        public MovingAverageType MAType1 { get; set; }

        [Parameter("MA 1 Source", Group = "MA 1")]
        public DataSeries Source1 { get; set; }

        [Parameter("MA 1 Periods", DefaultValue = 1, MinValue = 1, MaxValue = 100, Group = "MA 1")]
        public int Period1 { get; set; }

        [Parameter("MA 1 Shift", DefaultValue = 6, MinValue = -100, MaxValue = 500, Group = "MA 1")]
        public int Shift1 { get; set; }
        // Range Break Out (BO)
        [Parameter("Range BO High", DefaultValue = 0, MinValue = 0, MaxValue = 999999, Group = "Range BreakOut")]
        public double RBO_H { get; set; }
        // Range Break Out (BO)
        [Parameter("Range BO Low", DefaultValue = 0, MinValue = 0, MaxValue = 999999, Group = "Range BreakOut")]
        public double RBO_L { get; set; }

        [Parameter("Buy Orders Only", DefaultValue = false, Group = "OrderTypes")]
        public bool buyOrderOnly { get; set; }

        [Parameter("Sell Orders Only", DefaultValue = false, Group = "OrderTypes")]
        public bool sellOrderOnly { get; set; }

        // If this setting is enabled and you have no positions open
        // then the robot will place a trade on the next onBar(). Might result in poor entries.
        [Parameter("Aggressive re-entry", DefaultValue = false, Group = "OrderTypes")]
        public bool aggressiveReenter { get; set; }

        [Parameter("Print Debug", DefaultValue = true, Group = "Debug")]
        public bool IsDebug { get; set; }

        private SMAShift _ma1 { get; set; }

        public double candleClose;
        public double shiftedMAPrice;
        public bool buySellLogic;
        // true = foo, false = sell 
        protected override void OnStart()
        {
            Print("{0}: TimeFrame is: {1}", Symbol.Name, TimeFrame.ToString());

            _tradingTime = TradingDateTime();
            if (this.IsBacktesting)
            {
                Print("Using server time for trading (UTC+0): " + _tradingTime.ToLongTimeString());
            }
            else
            {
                Print("Using PC time for trading: " + _tradingTime.ToLongTimeString());
            }

            // RBO mode?
            if (RBO_H != 0 || RBO_L != 0)
            {
                Print("INFO: Range BreakOut Mode Enabled.");
                if (RBO_H != 0)
                {
                    Print("INFO: Range BreakOut Mode Enabled. Only buying above: High: {0}", RBO_H);
                }
                if (RBO_L != 0)
                {
                    Print("INFO: Range BreakOut Mode Enabled. Only selling below: Low: {0}", RBO_L);
                }
            }
            // Check for stupid config
            if (buyOrderOnly && sellOrderOnly)
            {
                Print("FATAL: Buy and Sell Order Only both enabled. No trades can be made. Quitting.");
                Stop();
            }

            if (aggressiveReenter)
            {
                Print("INFO: Aggressive re-entry is ENABLED. Trades will opened on next bar and everytime SL or TP is hit");
            }

            // Init our MA indicator
            _ma1 = Indicators.GetIndicator<SMAShift>(MAType1, Source1, Period1, Shift1);

            // Work Out Buy/Sell once per cross-over logic
            int index = MarketSeries.Close.Count - 2;
            candleClose = MarketSeries.Close[index];
            // Set MA to var
            shiftedMAPrice = _ma1.Result.Last(Shift1);
            if (candleClose > shiftedMAPrice)
            {
                debug("DEBUG: Last close above MA. We are in long zone");
                // true = buy/LongZone
                buySellLogic = true;
            }
            else
            {
                debug("DEBUG: Last close below MA. We are in short zone");
                // false = sell/ShortZone
                buySellLogic = false;
            }

        }

        protected override void OnTick()
        {
            TRAILING();

            //debug("Current MA: {0},  Shifted MA: {1}", _ma1.Result.Last(0), _ma1.Result.Last(Shift1));
        }

        protected override void OnBar()
        {
            //TRAILING();

            debug("Current MA: {0},  Shifted MA: {1}", _ma1.Result.Last(0), _ma1.Result.Last(Shift1));

            // Configure Price
            // -2 Closed Bar / -1 Current Bar
            int index = MarketSeries.Close.Count - 2;
            candleClose = MarketSeries.Close[index];
            // Set MA to var
            shiftedMAPrice = _ma1.Result.Last(Shift1);

            debug("PreviousBar Close: {0}", candleClose);
            debug("ShiftedMAPrice : {0}", shiftedMAPrice);


            if (candleClose > shiftedMAPrice)
            {
                if (Positions.Count(x => x.TradeType == TradeType.Sell) != 0)
                {
                    ClosePosition(TradeType.Sell);
                }
                if (!sellOrderOnly)
                {
                    // Have we broken out of a range
                    if (candleClose > RBO_H || RBO_H == 0)
                    {
                        // if buySellLogic is false, we were previously in sell/ShortZone
                        if (!buySellLogic || aggressiveReenter)
                            if (Positions.Count(x => x.TradeType == TradeType.Buy) == 0)
                            {
                                debug("IF1");
                                debug("ExecuteMarketOrder(TradeType.Buy)");
                                debug("ClosePosition(TradeType.Sell)");
                                double volume = Symbol.QuantityToVolumeInUnits(lotsize);
                                ExecuteMarketOrder(TradeType.Buy, this.SymbolName, volume, InstanceName, SL, TP);
                                buySellLogic = true;
                            }
                    }
                }
            }


            if (candleClose < shiftedMAPrice)
            {
                if (Positions.Count(x => x.TradeType == TradeType.Buy) != 0)
                {
                    ClosePosition(TradeType.Buy);
                }

                if (!buyOrderOnly)
                {
                    // Have we broken out of a range
                    if (candleClose < RBO_L || RBO_L == 0)
                    {
                        // if buySellLogic is true, we were previously in buy/LongZone
                        if (buySellLogic || aggressiveReenter)
                            if (Positions.Count(x => x.TradeType == TradeType.Sell) == 0)
                            {
                                {
                                    debug("IF2");
                                    debug("ExecuteMarketOrder(TradeType.Sell)");
                                    debug("ClosePosition(TradeType.Buy)");

                                    double volume = Symbol.QuantityToVolumeInUnits(lotsize);
                                    ExecuteMarketOrder(TradeType.Sell, SymbolName, volume, InstanceName, SL, TP);
                                    buySellLogic = false;
                                }
                            }
                    }
                }
            }
        }

        protected override void OnStop()
        {
            Stop();
        }

        public DateTime TradingDateTime()
        {
            if (this.IsBacktesting)
            {
                return Server.Time;
            }
            else
            {
                return TimeZoneInfo.ConvertTime(DateTime.Now, TimeZoneInfo.Local);
            }
        }

        private void ClosePosition(TradeType type)
        {
            var p = Positions.Find(InstanceName, this.SymbolName, type);

            if (p != null)
            {
                ClosePosition(p);
                debug("ClosePosition()");
            }
        }

        private void debug(string myMessage)
        {
            if (IsDebug)
            {
                Print(myMessage);
            }
        }
        private void debug(string myMessage, double myMessage2)
        {
            if (IsDebug)
            {
                Print(myMessage, myMessage2);
            }
        }
        private void debug(string myMessage, double myMessage2, double myMessage3)
        {
            if (IsDebug)
            {
                Print(myMessage, myMessage2, myMessage3);
            }
        }


        private void TRAILING()
        {
            if (Trailing > 0 && Trigger > 0)
            {
                Position[] positions = Positions.FindAll(InstanceName, SymbolName);
                foreach (Position position in positions)
                {
                    if (position.TradeType == TradeType.Sell)
                    {
                        double distance = position.EntryPrice - Symbol.Ask;
                        if (distance >= Trigger * Symbol.PipSize)
                        {
                            double newStopLossPrice = Symbol.Ask + Trailing * Symbol.PipSize;
                            if (position.StopLoss == null || newStopLossPrice < position.StopLoss)
                            {
                                //Print("StopLoss / ModifyPosition");
                                ModifyPosition(position, newStopLossPrice, position.TakeProfit);
                            }
                        }
                    }

                    else
                    {
                        double distance = Symbol.Bid - position.EntryPrice;
                        if (distance >= Trigger * Symbol.PipSize)
                        {
                            double newStopLossPrice = Symbol.Bid - Trailing * Symbol.PipSize;
                            if (position.StopLoss == null || newStopLossPrice > position.StopLoss)
                            {
                                //Print("StopLoss / ModifyPosition2");
                                ModifyPosition(position, newStopLossPrice, position.TakeProfit);
                            }
                        }
                    }
                }
            }
        }

        // START - Play around with getFitness
        protected override double GetFitness(GetFitnessArgs args)
        {
            //return _fit_winLossRatio(args);
            //return _fit_MaxWinTrade_MinLosses(args);
            //return _fit_MaxWinTrade_MinLosses2(args);
            return _fit_PessimisticReturnOnMargin(args);
        }

        private double _fit_winLossRatio(GetFitnessArgs args)
        {
            return args.WinningTrades / (args.WinningTrades + args.LosingTrades + 1);
        }
        //maximize count of winning trades and minimize count of losing trades
        private double _fit_MaxWinTrade_MinLosses(GetFitnessArgs args)
        {
            return (args.NetProfit * args.WinningTrades * TP) / (args.MaxEquityDrawdownPercentages * SL);
        }
        private double _fit_MaxWinTrade_MinLosses2(GetFitnessArgs args)
        {
            return (Math.Pow(args.NetProfit, 3) * Math.Pow(args.WinningTrades, 2) * (TP / SL)) / (Math.Pow(args.MaxEquityDrawdownPercentages, 2) * TP * SL * args.MaxEquityDrawdown);
        }
        private double _fit_PessimisticReturnOnMargin(GetFitnessArgs args)
        {
            // Change the value below to your account size
            var AccountSize = 10000;
            // check for errors / wrong values
            if (AccountSize < 1 || args.WinningTrades == 0 || args.LosingTrades == 0)
            {
                return 0;
            }

            double WinTradeTotal = 0.0;
            double LossTradeTotal = 0.0;
            int WinTradeCount = 0;
            int LossTradeCount = 0;
            double AvgWinningTrade = 0.0;
            double AvgLosingTrade = 0.0;
            foreach (HistoricalTrade trade in History)
            {
                if (trade.NetProfit > 0.01)
                {
                    WinTradeTotal = WinTradeTotal + trade.NetProfit;
                    WinTradeCount++;
                    //Print("WinTradeTotal: {0}, WinTradeCount {1}", WinTradeTotal, WinTradeCount);
                }
                else
                {
                    LossTradeTotal = LossTradeTotal + trade.NetProfit;
                    LossTradeCount++;
                    //Print("LossTradeTotal: {0}, LossTradeCount {1}", LossTradeTotal, LossTradeCount);
                }
            }
            AvgWinningTrade = Math.Round(WinTradeTotal / WinTradeCount, 2);
            AvgLosingTrade = (Math.Round(LossTradeTotal / LossTradeCount, 2) * -1);
            //Print("AvgWinningTrade: {0}, AvgLosingTrade {1}", AvgWinningTrade, AvgLosingTrade);

            var sqrtWins = Math.Sqrt(args.WinningTrades);
            var sqrtLosses = Math.Sqrt(args.LosingTrades);

            return (((AvgWinningTrade * (args.WinningTrades - sqrtWins)) - (AvgLosingTrade * (args.LosingTrades - sqrtLosses))) / AccountSize) * 100;
        }

        // END - Play around with getFitness

    }
}
